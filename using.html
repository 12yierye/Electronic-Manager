<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NaOH体积变化对pH值的影响趋势</title>
    
    <!-- 内联Tailwind CSS最小化版本 -->
    <style>
        /*! tailwindcss v3.0.0 | MIT License | https://tailwindcss.com */
        * { -webkit-user-select: none; user-select: none; }
        *, ::before, ::after { box-sizing: border-box; border-width: 0; border-style: solid; border-color: #e5e7eb; }
        html { line-height: 1.5; -webkit-text-size-adjust: 100%; -moz-text-size-adjust: 100%; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; -moz-text-size-adjust: 100%; -ms-text-size-adjust: 100%; text-size-adjust: 100%; -moz-tab-size: 4; tab-size: 4; font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; }
        body { margin: 0; line-height: inherit; }
        hr { height: 0; color: inherit; border-top-width: 1px; }
        abbr:where([title]) { text-decoration: underline dotted; }
        h1, h2, h3, h4, h5, h6 { font-size: inherit; font-weight: inherit; }
        a { color: inherit; text-decoration: inherit; }
        b, strong { font-weight: bolder; }
        code, kbd, samp, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 1em; }
        small { font-size: 80%; }
        sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
        sub { bottom: -0.25em; }
        sup { top: -0.5em; }
        table { text-indent: 0; border-color: inherit; border-collapse: collapse; }
        button, input, optgroup, select, textarea { font-family: inherit; font-size: 100%; font-weight: inherit; line-height: inherit; color: inherit; margin: 0; padding: 0; }
        button, select { text-transform: none; }
        button, [type='button'], [type='reset'], [type='submit'] { -webkit-appearance: button; appearance: button; background-color: transparent; background-image: none; }
        :-moz-focusring { outline: auto; }
        :-moz-ui-invalid { box-shadow: none; }
        progress { vertical-align: baseline; }
        ::file-selector-button { -webkit-appearance: button; appearance: button; font: inherit; }
        summary { display: list-item; }
        blockquote, dl, dd, h1, h2, h3, h4, h5, h6, hr, figure, p, pre { margin: 0; }
        fieldset { margin: 0; padding: 0; }
        legend { padding: 0; }
        ol, ul, menu { list-style: none; margin: 0; padding: 0; }
        textarea { resize: vertical; }
        input::placeholder, textarea::placeholder { opacity: 1; color: #9ca3af; }
        button, [role="button"] { cursor: pointer; }
        :disabled { cursor: default; }
        img, svg { display: block; max-width: 100%; height: auto; }
        
        /* 自定义容器和布局类 */
        .container { width: 100%; }
        @media (min-width: 640px) { .container { max-width: 640px; } }
        @media (min-width: 768px) { .container { max-width: 768px; } }
        @media (min-width: 1024px) { .container { max-width: 1024px; } }
        @media (min-width: 1280px) { .container { max-width: 1280px; } }
        @media (min-width: 1536px) { .container { max-width: 1536px; } }
        
        /* 基础样式类 */
        .mx-auto { margin-left: auto; margin-right: auto; }
        .mb-8 { margin-bottom: 2rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mr-2 { margin-right: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .p-6 { padding: 1.5rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-8 { padding-top: 2rem; padding-bottom: 2rem; }
        .p-3 { padding: 0.75rem; }
        .p-5 { padding: 1.25rem; }
        .text-center { text-align: center; }
        .font-bold { font-weight: 700; }
        .font-semibold { font-weight: 600; }
        .font-medium { font-weight: 500; }
        .text-\[clamp\(1\.5rem\2c 3vw\2c 2\.2rem\)\] { font-size: clamp(1.5rem,3vw,2.2rem); }
        .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
        .text-gray-800 { color: #1f2937; }
        .text-gray-600 { color: #4b5563; }
        .text-primary { color: #3B82F6; }
        .text-acid { color: #EF4444; }
        .text-neutral { color: #F59E0B; }
        .text-base { color: #8B5CF6; }
        .bg-white { background-color: #fff; }
        .bg-gray-50 { background-color: #f9fafb; }
        .rounded-xl { border-radius: 0.75rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .rounded-full { border-radius: 9999px; }
        .shadow { box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
        .shadow-lg { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        .border { border-width: 1px; }
        .border-l-4 { border-left-width: 4px; }
        .border-acid { border-color: #EF4444; }
        .border-neutral { border-color: #F59E0B; }
        .border-base { border-color: #8B5CF6; }
        .border-gray-200 { border-color: #e5e7eb; }
        .flex { display: flex; }
        .hidden { display: none; }
        .items-center { align-items: center; }
        .grid { display: grid; }
        .relative { position: relative; }
        .absolute { position: absolute; }
        .overflow-hidden { overflow: hidden; }
        .space-y-4 > :not([hidden]) ~ :not([hidden]) { --tw-space-y-reverse: 0; margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse))); margin-bottom: calc(1rem * var(--tw-space-y-reverse)); }
        .space-y-2 > :not([hidden]) ~ :not([hidden]) { --tw-space-y-reverse: 0; margin-top: calc(0.5rem * calc(1 - var(--tw-space-y-reverse))); margin-bottom: calc(0.5rem * var(--tw-space-y-reverse)); }
        .w-full { width: 100%; }
        .h-1 { height: 0.25rem; }
        .h-full { height: 100%; }
        .z-10 { z-index: 10; }
        .transition { transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .ease-in-out { transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); }
        .duration-300 { transition-duration: 300ms; }
        
        @media (min-width: 768px) {
          .md\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        }
        
        /* 自定义工具类 */
        .trend-container {
            position: relative;
            height: 600px;
            width: 100%;
        }
        .volume-marker {
            transition: all 0.3s ease;
            z-index: 10;
        }
        .volume-marker:hover {
            transform: scale(1.1);
        }
        .gradient-bg {
            background: linear-gradient(180deg, rgba(239,68,68,0.05) 0%, rgba(245,158,11,0.05) 50%, rgba(139,92,246,0.05) 100%);
        }
        #phProgress {
            width: 7%;
            transition: width 0.3s ease;
        }
        
        /* Font Awesome 图标基础样式 */
        .fa {
            display: inline-block;
            font: normal normal normal 14px/1 FontAwesome;
            font-size: inherit;
            text-rendering: auto;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .fa-arrow-right:before { content: "\f061"; }
        .fa-bolt:before { content: "\f0e7"; }
        .fa-arrow-up:before { content: "\f062"; }
        
        /* 新增样式：改善视觉效果 */
        .card-hover {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card-hover:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        
        .tracker-fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* 改进阶段卡片样式 */
        .phase-card {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .phase-icon {
            min-width: 20px;
        }
        
        .phase-content {
            flex-grow: 1;
        }
        
        /* 调整阶段卡片容器宽度和间距，使其与上方图表容器等宽 */
        .phase-cards-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            width: 100%;
        }
        
        .phase-card-wrapper {
            flex: 1;
            min-width: 250px;
        }
        
        @media (max-width: 768px) {
            .phase-card-wrapper {
                min-width: 100%;
            }
        }
    </style>
    
    <!-- 内联Chart.js库 -->
    <script>
        // Chart.js v3.9.1 精简但功能完整的版本
        // 实现pH变化趋势图所需的核心功能
        
        // Chart.js核心对象
        var Chart = (function() {
            // 简化的事件系统
            function EventEmitter() {
                this.events = {};
            }
            
            EventEmitter.prototype.on = function(event, callback) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(callback);
            };
            
            EventEmitter.prototype.emit = function(event, data) {
                if (this.events[event]) {
                    this.events[event].forEach(function(callback) {
                        callback(data);
                    });
                }
            };
            
            // 工具函数
            function extend(target, source) {
                Object.keys(source).forEach(function(key) {
                    target[key] = source[key];
                });
                return target;
            }
            
            function clone(obj) {
                return JSON.parse(JSON.stringify(obj));
            }
            
            // 线性插值
            function interpolate(start, end, progress) {
                return start + (end - start) * progress;
            }
            
            // 获取鼠标位置
            function getMousePos(canvas, evt) {
                var rect = canvas.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }
            
            // Chart类
            function Chart(context, config) {
                this.ctx = context;
                this.config = config;
                this.data = config.data;
                this.options = config.options || {};
                
                // 设置默认选项
                this.options = extend({
                    responsive: true,
                    animation: {
                        duration: 1000
                    },
                    interaction: {
                        mode: 'nearest',
                        intersect: true
                    },
                    plugins: {
                        legend: {
                            display: true
                        },
                        tooltip: {
                            enabled: true
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: false
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: false
                            }
                        }
                    }
                }, this.options);
                
                // 初始化
                this.init();
            }
            
            Chart.prototype.init = function() {
                this.setupCanvas();
                this.calculateBounds();
                this.draw();
                
                // 添加鼠标交互
                this.setupInteraction();
            };
            
            Chart.prototype.setupCanvas = function() {
                var canvas = this.ctx.canvas;
                var displayWidth = canvas.clientWidth;
                var displayHeight = canvas.clientHeight;
                
                if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                    canvas.width = displayWidth;
                    canvas.height = displayHeight;
                    this.ctx = canvas.getContext('2d');
                }
            };
            
            Chart.prototype.calculateBounds = function() {
                var datasets = this.data.datasets;
                if (!datasets || datasets.length === 0) return;
                
                // 计算X和Y轴的范围
                var xMin = Infinity, xMax = -Infinity;
                var yMin = Infinity, yMax = -Infinity;
                
                datasets.forEach(function(dataset) {
                    if (dataset.data) {
                        dataset.data.forEach(function(point) {
                            if (point.x !== undefined && point.y !== undefined) {
                                xMin = Math.min(xMin, point.x);
                                xMax = Math.max(xMax, point.x);
                                yMin = Math.min(yMin, point.y);
                                yMax = Math.max(yMax, point.y);
                            } else if (Array.isArray(point) && point.length >= 2) {
                                xMin = Math.min(xMin, point[0]);
                                xMax = Math.max(xMax, point[0]);
                                yMin = Math.min(yMin, point[1]);
                                yMax = Math.max(yMax, point[1]);
                            } else if (typeof point === 'object' && point.volume !== undefined && point.ph !== undefined) {
                                xMin = Math.min(xMin, point.volume);
                                xMax = Math.max(xMax, point.volume);
                                yMin = Math.min(yMin, point.ph);
                                yMax = Math.max(yMax, point.ph);
                            }
                        });
                    }
                });
                
                this.bounds = {
                    x: { min: xMin, max: xMax },
                    y: { min: yMin, max: yMax }
                };
                
                // 添加一些边距
                var xMargin = (xMax - xMin) * 0.05;
                var yMargin = (yMax - yMin) * 0.05;
                
                this.bounds.x.min -= xMargin;
                this.bounds.x.max += xMargin;
                this.bounds.y.min -= yMargin;
                this.bounds.y.max += yMargin;
            };
            
            Chart.prototype.draw = function() {
                var ctx = this.ctx;
                var canvas = ctx.canvas;
                var width = canvas.width;
                var height = canvas.height;
                
                // 清空画布
                ctx.clearRect(0, 0, width, height);
                
                // 绘制背景
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);
                
                // 计算绘图区域（考虑边距）
                var chartArea = {
                    left: 60,
                    top: 20,
                    right: width - 20,
                    bottom: height - 50,
                    width: width - 80,
                    height: height - 70
                };
                
                this.chartArea = chartArea;
                
                // 绘制网格和轴
                this.drawGrid(chartArea);
                
                // 绘制数据集
                this.drawDatasets(chartArea);
                
                // 绘制轴标签
                this.drawAxisLabels(chartArea);
            };
            
            Chart.prototype.drawGrid = function(chartArea) {
                var ctx = this.ctx;
                var xScale = this.options.scales.x;
                var yScale = this.options.scales.y;
                
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                
                // 绘制Y轴网格线
                if (yScale.ticks && yScale.ticks.stepSize) {
                    var step = yScale.ticks.stepSize;
                    var minY = Math.ceil(this.bounds.y.min / step) * step;
                    var maxY = Math.floor(this.bounds.y.max / step) * step;
                    
                    for (var y = minY; y <= maxY; y += step) {
                        var yPos = this.getYPixel(y, chartArea);
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yPos);
                        ctx.lineTo(chartArea.right, yPos);
                        ctx.stroke();
                    }
                }
                
                // 绘制X轴网格线
                if (xScale.ticks && xScale.ticks.stepSize) {
                    var step = xScale.ticks.stepSize;
                    var minX = Math.ceil(this.bounds.x.min / step) * step;
                    var maxX = Math.floor(this.bounds.x.max / step) * step;
                    
                    for (var x = minX; x <= maxX; x += step) {
                        var xPos = this.getXPixel(x, chartArea);
                        ctx.beginPath();
                        ctx.moveTo(xPos, chartArea.top);
                        ctx.lineTo(xPos, chartArea.bottom);
                        ctx.stroke();
                    }
                }
                
                // 绘制轴线
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                
                // X轴
                ctx.beginPath();
                ctx.moveTo(chartArea.left, chartArea.bottom);
                ctx.lineTo(chartArea.right, chartArea.bottom);
                ctx.stroke();
                
                // Y轴
                ctx.beginPath();
                ctx.moveTo(chartArea.left, chartArea.top);
                ctx.lineTo(chartArea.left, chartArea.bottom);
                ctx.stroke();
            };
            
            Chart.prototype.drawAxisLabels = function(chartArea) {
                var ctx = this.ctx;
                var xScale = this.options.scales.x;
                var yScale = this.options.scales.y;
                
                ctx.fillStyle = '#000000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                // X轴标签
                if (xScale.ticks && xScale.ticks.stepSize) {
                    var step = xScale.ticks.stepSize;
                    var minX = Math.ceil(this.bounds.x.min / step) * step;
                    var maxX = Math.floor(this.bounds.x.max / step) * step;
                    
                    for (var x = minX; x <= maxX; x += step) {
                        var xPos = this.getXPixel(x, chartArea);
                        var label = xScale.ticks.callback ? xScale.ticks.callback(x) : x;
                        
                        ctx.fillText(label, xPos, chartArea.bottom + 5);
                    }
                }
                
                // X轴标题
                if (xScale.title && xScale.title.display && xScale.title.text) {
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText(xScale.title.text, (chartArea.left + chartArea.right) / 2, chartArea.bottom + 30);
                }
                
                // Y轴标签
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                
                if (yScale.ticks && yScale.ticks.stepSize) {
                    var step = yScale.ticks.stepSize;
                    var minY = Math.ceil(this.bounds.y.min / step) * step;
                    var maxY = Math.floor(this.bounds.y.max / step) * step;
                    
                    for (var y = minY; y <= maxY; y += step) {
                        var yPos = this.getYPixel(y, chartArea);
                        var label = yScale.ticks.callback ? yScale.ticks.callback(y) : y;
                        
                        ctx.fillText(label, chartArea.left - 10, yPos);
                    }
                }
                
                // Y轴标题
                if (yScale.title && yScale.title.display && yScale.title.text) {
                    ctx.save();
                    ctx.translate(15, (chartArea.top + chartArea.bottom) / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.textAlign = 'center';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText(yScale.title.text, 0, 0);
                    ctx.restore();
                }
            };
            
            Chart.prototype.drawDatasets = function(chartArea) {
                var ctx = this.ctx;
                var datasets = this.data.datasets;
                
                if (!datasets) return;
                
                for (var i = 0; i < datasets.length; i++) {
                    var dataset = datasets[i];
                    this.drawDataset(dataset, chartArea, i);
                }
            };
            
            Chart.prototype.drawDataset = function(dataset, chartArea, index) {
                var ctx = this.ctx;
                var data = dataset.data;
                
                if (!data || data.length === 0) return;
                
                if (dataset.showLine !== false) {
                    // 绘制线条
                    ctx.beginPath();
                    ctx.lineWidth = dataset.borderWidth || 2;
                    ctx.strokeStyle = dataset.borderColor || '#000000';
                    
                    for (var i = 0; i < data.length; i++) {
                        var point = data[i];
                        var x, y;
                        
                        if (point.x !== undefined && point.y !== undefined) {
                            x = this.getXPixel(point.x, chartArea);
                            y = this.getYPixel(point.y, chartArea);
                        } else if (Array.isArray(point) && point.length >= 2) {
                            x = this.getXPixel(point[0], chartArea);
                            y = this.getYPixel(point[1], chartArea);
                        } else if (typeof point === 'object' && point.volume !== undefined && point.ph !== undefined) {
                            x = this.getXPixel(point.volume, chartArea);
                            y = this.getYPixel(point.ph, chartArea);
                        } else {
                            continue;
                        }
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            // 使用简单的线性连接或者带张力的贝塞尔曲线
                            if (dataset.tension && dataset.tension > 0) {
                                // 简化的张力处理
                                var prevPoint = data[i-1];
                                var prevX, prevY;
                                
                                if (prevPoint.x !== undefined && prevPoint.y !== undefined) {
                                    prevX = this.getXPixel(prevPoint.x, chartArea);
                                    prevY = this.getYPixel(prevPoint.y, chartArea);
                                } else if (Array.isArray(prevPoint) && prevPoint.length >= 2) {
                                    prevX = this.getXPixel(prevPoint[0], chartArea);
                                    prevY = this.getYPixel(prevPoint[1], chartArea);
                                } else if (typeof prevPoint === 'object' && prevPoint.volume !== undefined && prevPoint.ph !== undefined) {
                                    prevX = this.getXPixel(prevPoint.volume, chartArea);
                                    prevY = this.getYPixel(prevPoint.ph, chartArea);
                                }
                                
                                var cpX = prevX + (x - prevX) * 0.5;
                                ctx.bezierCurveTo(cpX, prevY, cpX, y, x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                    }
                    
                    ctx.stroke();
                }
                
                // 绘制数据点
                if (dataset.pointRadius !== 0) {
                    var pointRadius = dataset.pointRadius || 3;
                    
                    for (var i = 0; i < data.length; i++) {
                        var point = data[i];
                        var x, y;
                        
                        if (point.x !== undefined && point.y !== undefined) {
                            x = this.getXPixel(point.x, chartArea);
                            y = this.getYPixel(point.y, chartArea);
                        } else if (Array.isArray(point) && point.length >= 2) {
                            x = this.getXPixel(point[0], chartArea);
                            y = this.getYPixel(point[1], chartArea);
                        } else if (typeof point === 'object' && point.volume !== undefined && point.ph !== undefined) {
                            x = this.getXPixel(point.volume, chartArea);
                            y = this.getYPixel(point.ph, chartArea);
                        } else {
                            continue;
                        }
                        
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius, 0, Math.PI * 2);
                        ctx.fillStyle = dataset.backgroundColor || dataset.borderColor || '#000000';
                        ctx.fill();
                        ctx.strokeStyle = dataset.borderColor || '#ffffff';
                        ctx.lineWidth = dataset.borderWidth || 1;
                        ctx.stroke();
                    }
                }
            };
            
            Chart.prototype.getXPixel = function(val, chartArea) {
                return chartArea.left + ((val - this.bounds.x.min) / (this.bounds.x.max - this.bounds.x.min)) * chartArea.width;
            };
            
            Chart.prototype.getYPixel = function(val, chartArea) {
                return chartArea.bottom - ((val - this.bounds.y.min) / (this.bounds.y.max - this.bounds.y.min)) * chartArea.height;
            };
            
            // 设置交互
            Chart.prototype.setupInteraction = function() {
                var self = this;
                var canvas = this.ctx.canvas;
                var tooltipEl = document.getElementById('volumeTracker');
                
                canvas.addEventListener('mousemove', function(evt) {
                    var mousePos = getMousePos(canvas, evt);
                    var chartArea = self.chartArea;
                    
                    if (!chartArea) return;
                    
                    // 检查是否在图表区域内
                    if (mousePos.x >= chartArea.left && mousePos.x <= chartArea.right &&
                        mousePos.y >= chartArea.top && mousePos.y <= chartArea.bottom) {
                        
                        // 计算对应的体积值
                        var volume = self.bounds.x.min + ((mousePos.x - chartArea.left) / chartArea.width) * (self.bounds.x.max - self.bounds.x.min);
                        
                        // 查找最近的数据点
                        var closestPoint = self.findClosestPoint(volume);
                        if (closestPoint) {
                            // 显示追踪器
                            self.showTracker(closestPoint, mousePos);
                        }
                    } else {
                        // 隐藏追踪器
                        self.hideTracker();
                    }
                });
                
                canvas.addEventListener('mouseout', function() {
                    self.hideTracker();
                });
            };
            
            // 查找最近的点
            Chart.prototype.findClosestPoint = function(volume) {
                var datasets = this.data.datasets;
                if (!datasets || datasets.length === 0) return null;
                
                var trendData = datasets[0].data;
                if (!trendData || trendData.length === 0) return null;
                
                // 查找最接近的点
                var closestPoint = null;
                var minDistance = Infinity;
                
                for (var i = 0; i < trendData.length; i++) {
                    var point = trendData[i];
                    var distance = Math.abs(point.volume - volume);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPoint = point;
                    }
                }
                
                return closestPoint;
            };
            
            // 显示追踪器
            Chart.prototype.showTracker = function(point, mousePos) {
                var tracker = document.getElementById('volumeTracker');
                var volumeDisplay = document.getElementById('trackedVolume');
                var phDisplay = document.getElementById('trackedPh');
                var phProgress = document.getElementById('phProgress');
                
                // 更新数据显示
                volumeDisplay.textContent = point.volume.toFixed(2) + ' mL';
                phDisplay.textContent = point.ph.toFixed(2);
                phDisplay.style.color = this.getPhColor(point.ph);
                phProgress.style.width = ((point.ph / 14) * 100) + '%';
                phProgress.style.backgroundColor = this.getPhColor(point.ph);
                
                // 定位追踪器
                tracker.style.left = (mousePos.x + 15) + 'px';
                tracker.style.top = (mousePos.y - 80) + 'px';
                
                // 显示并添加动画效果
                tracker.classList.remove('hidden');
                tracker.classList.add('tracker-fade-in');
            };
            
            // 隐藏追踪器
            Chart.prototype.hideTracker = function() {
                var tracker = document.getElementById('volumeTracker');
                tracker.classList.add('hidden');
                tracker.classList.remove('tracker-fade-in');
            };
            
            // 根据pH值获取对应颜色
            Chart.prototype.getPhColor = function(ph) {
                if (ph < 7) {
                    // 酸性：从红色到黄色过渡
                    var ratio = ph / 7;
                    var r = 239;
                    var g = Math.round(68 + (190 * ratio));
                    var b = 68;
                    return 'rgb(' + r + ', ' + g + ', ' + b + ')';
                } else {
                    // 碱性：从黄色到紫色过渡
                    var ratio = (ph - 7) / 7;
                    var r = Math.round(245 - (106 * ratio));
                    var g = Math.round(158 - (66 * ratio));
                    var b = Math.round(11 + (235 * ratio));
                    return 'rgb(' + r + ', ' + g + ', ' + b + ')';
                }
            };
            
            // 注册全局配置
            Chart.defaults = {
                color: '#666',
                font: {
                    family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                    size: 12,
                    style: 'normal',
                    lineHeight: 1.2
                }
            };
            
            return Chart;
        })();
    </script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        acid: '#EF4444',
                        neutral: '#F59E0B',
                        base: '#8B5CF6',
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto px-4 py-8 max-w-5xl">
        <header class="mb-8 text-center">
            <h1 class="text-[clamp(1.5rem,3vw,2.2rem)] font-bold text-gray-800 mb-2">
                NaOH体积变化对pH值的影响趋势
            </h1>
            <p class="text-gray-600">0.10mol/L NaOH滴定20.00mL 0.10mol/L HCl的pH变化趋势</p>
        </header>

        <div class="bg-white rounded-xl shadow-lg p-6 mb-8 gradient-bg">
            <div class="trend-container">
                <canvas id="trendChart"></canvas>
                
                <!-- 动态跟踪指示器 -->
                <div id="volumeTracker" class="hidden absolute bg-white border border-gray-200 rounded-lg shadow-lg p-3">
                    <div class="text-sm font-medium mb-1">NaOH体积: <span id="trackedVolume" class="text-primary">0.00 mL</span></div>
                    <div class="text-sm font-medium">pH值: <span id="trackedPh" class="text-acid">1.00</span></div>
                    <div class="w-full h-1 bg-gray-200 mt-2 rounded-full overflow-hidden">
                        <div id="phProgress" class="h-full bg-acid"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 调整后的阶段卡片容器，宽度与上方图表容器一致 -->
        <div class="phase-cards-container mb-8">
            <div class="phase-card-wrapper">
                <div class="bg-white p-5 rounded-lg shadow border-l-4 border-acid card-hover phase-card">
                    <h3 class="font-semibold text-lg mb-2 flex items-center">
                        <i class="fa fa-arrow-right mr-2 phase-icon"></i>酸性阶段
                    </h3>
                    <p class="text-sm text-gray-600 phase-content">
                        当NaOH体积在0-19.9mL范围时，pH值缓慢上升（1.00→4.30），每增加1mL NaOH，pH平均仅上升0.17个单位。
                    </p>
                </div>
            </div>
            <div class="phase-card-wrapper">
                <div class="bg-white p-5 rounded-lg shadow border-l-4 border-neutral card-hover phase-card">
                    <h3 class="font-semibold text-lg mb-2 flex items-center">
                        <i class="fa fa-bolt mr-2 phase-icon"></i>突跃阶段
                    </h3>
                    <p class="text-sm text-gray-600 phase-content">
                        当NaOH体积在19.9-20.1mL范围时，pH值急剧上升（4.30→9.70），仅0.2mL的体积变化就带来5.4个pH单位的跃升。
                    </p>
                </div>
            </div>
            <div class="phase-card-wrapper">
                <div class="bg-white p-5 rounded-lg shadow border-l-4 border-base card-hover phase-card">
                    <h3 class="font-semibold text-lg mb-2 flex items-center">
                        <i class="fa fa-arrow-up mr-2 phase-icon"></i>碱性阶段
                    </h3>
                    <p class="text-sm text-gray-600 phase-content">
                        当NaOH体积超过20.1mL后，pH值缓慢上升（9.70→12.52），每增加1mL NaOH，pH平均仅上升0.08个单位。
                    </p>
                </div>
            </div>
        </div>

        <div class="bg-white rounded-xl shadow p-6">
            <h2 class="text-xl font-semibold mb-4 text-primary">体积变化与pH趋势关系分析</h2>
            <div class="space-y-4 text-gray-700">
                <p>从趋势图可以清晰观察到，NaOH体积变化对pH值的影响呈现明显的三阶段性：</p>
                <ul class="list-disc pl-5 space-y-2">
                    <li>在化学计量点（20.00mL）前，由于H+过量，即使加入较多NaOH，溶液仍保持酸性，pH变化平缓；</li>
                    <li>接近计量点时，溶液中H+浓度极低，少量NaOH即可使H+浓度发生巨大变化，表现为pH值的突跃；</li>
                    <li>计量点后，由于OH-过量，溶液呈碱性，继续加入NaOH对pH值的影响再次变得平缓。</li>
                </ul>
                <p>这种趋势特征是强碱滴定强酸的典型表现，pH突跃范围（4.3~9.7）为选择指示剂提供了重要依据。</p>
            </div>
        </div>
    </div>

    <script>
        // 生成更精细的体积变化与pH值对应数据
        function generateVolumeTrendData() {
            const data = [];
            const hclInitial = 0.10;    // HCl初始浓度(mol/L)
            const hclVolume = 20.00;    // HCl初始体积(mL)
            const naohConcentration = 0.10;  // NaOH浓度(mol/L)
            
            // 生成数据点：根据体积变化密度动态调整采样间隔
            // 远离计量点区域：较疏采样
            for (let v = 0; v < 19.5; v += 0.5) {
                const hclRemaining = hclInitial * (hclVolume - v) / (hclVolume + v);
                const ph = -Math.log10(hclRemaining);
                data.push({ volume: v, ph: ph });
            }
            
            // 接近计量点区域：加密采样（突出变化趋势）
            for (let v = 19.5; v < 19.95; v += 0.05) {
                const hclRemaining = hclInitial * (hclVolume - v) / (hclVolume + v);
                const ph = -Math.log10(hclRemaining);
                data.push({ volume: v, ph: ph });
            }
            
            // 计量点附近：超高密度采样（精确展示突跃趋势）
            for (let v = 19.95; v <= 20.05; v += 0.001) {
                let ph;
                if (v < 20) {
                    const hclRemaining = hclInitial * (hclVolume - v) / (hclVolume + v);
                    ph = -Math.log10(hclRemaining);
                } else if (v > 20) {
                    const naohExcess = naohConcentration * (v - hclVolume) / (hclVolume + v);
                    ph = 14 + Math.log10(naohExcess);
                } else {
                    ph = 7.0;  // 计量点
                }
                data.push({ volume: v, ph: ph });
            }
            
            // 计量点后区域：加密采样
            for (let v = 20.05; v < 20.5; v += 0.05) {
                const naohExcess = naohConcentration * (v - hclVolume) / (hclVolume + v);
                const ph = 14 + Math.log10(naohExcess);
                data.push({ volume: v, ph: ph });
            }
            
            // 远离计量点区域：较疏采样
            for (let v = 20.5; v <= 40; v += 0.5) {
                const naohExcess = naohConcentration * (v - hclVolume) / (hclVolume + v);
                const ph = 14 + Math.log10(naohExcess);
                data.push({ volume: v, ph: ph });
            }
            
            return data;
        }

        // 关键体积点（用于标记趋势转折点）
        const keyVolumePoints = [
            { volume: 0, ph: 1.00, label: '初始点' },
            { volume: 10, ph: 1.48, label: '半滴定' },
            { volume: 19.8, ph: 3.30, label: '突跃前' },
            { volume: 19.98, ph: 4.30, label: '突跃开始' },
            { volume: 20.00, ph: 7.00, label: '计量点', color: '#F59E0B' },
            { volume: 20.02, ph: 9.70, label: '突跃结束' },
            { volume: 40.00, ph: 12.52, label: '终点' }
        ];

        // 绘制体积变化趋势图
        document.addEventListener('DOMContentLoaded', function() {
            const ctx = document.getElementById('trendChart').getContext('2d');
            const trendData = generateVolumeTrendData();
            
            // 创建体积变化趋势线
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'pH变化趋势',
                            data: trendData,
                            borderColor: '#3B82F6',
                            borderWidth: 3,
                            pointRadius: 0,
                            tension: 0.2,
                            fill: false,
                            spanGaps: false
                        },
                        {
                            label: '关键体积点',
                            data: keyVolumePoints,
                            backgroundColor: keyVolumePoints.map(p => p.color || '#3B82F6'),
                            borderColor: '#FFFFFF',
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            showLine: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    animation: {
                        duration: 2500,
                        easing: 'easeOutQuart'
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                title: function() {
                                    return '滴定状态';
                                },
                                label: function(context) {
                                    const point = context.raw;
                                    return [
                                        'NaOH体积: ' + point.volume.toFixed(2) + ' mL',
                                        'pH值: ' + point.ph.toFixed(2)
                                    ];
                                }
                            }
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'NaOH加入体积 (mL)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                },
                                padding: { top: 15 }
                            },
                            min: 0,
                            max: 40,
                            ticks: {
                                stepSize: 5,
                                callback: function(value) {
                                    return value + ' mL';
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '溶液pH值',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                },
                                padding: { right: 15 }
                            },
                            min: 0,
                            max: 14,
                            ticks: {
                                stepSize: 1
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        }
                    }
                }
            });

            // 添加关键体积点标签
            keyVolumePoints.forEach(point => {
                if (point.label) {
                    // 等待图表绘制完成后再添加标签
                    setTimeout(() => {
                        const chartArea = chart.chartArea;
                        if (chartArea) {
                            const x = chart.getXPixel(point.volume, chartArea);
                            const y = chart.getYPixel(point.ph, chartArea);
                            
                            const label = document.createElement('div');
                            label.className = 'absolute bg-white px-2 py-1 rounded shadow text-sm font-medium text-gray-800 volume-marker';
                            label.textContent = point.label + ': ' + point.volume.toFixed(2) + 'mL';
                            label.style.left = (x + 10) + 'px';
                            label.style.top = (y - 20) + 'px';
                            label.style.pointerEvents = 'none';
                            label.style.border = '1px solid #e5e7eb';
                            label.style.zIndex = '20';
                            
                            document.querySelector('.trend-container').appendChild(label);
                        }
                    }, 100);
                }
            });
        });
    </script>
</body>
</html>